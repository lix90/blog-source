---
title: 数据库面试题解答
author: Li Xiang
date: 2016-11-19
layout: post
tags: [Database,SQL]
categories: [Notes]
---

内容来源：[知乎专栏-学习编程：常见面试题整理--数据库篇](https://zhuanlan.zhihu.com/p/23713529)

# 存储过程

什么是存储过程？优缺点？

存储过程：一个预编译的代码块（T-SQL），实现一系列功能（对表单或多表增删改查），然后方便调用。
优点：执行效率较高；降低网络通信量，提高通信效率；一定程度上确保数据安全。

我的问题：如何编写存储过程代码？

# 索引

什么是索引？作用？优缺点？使用索引查询一定能提高查询的性能吗？

索引：对数据库表中一或多个列的值进行**排序**的结构，能够**加快数据检索**，允许数据库程序迅速找到表中数据，而不必扫描整个数据库。
MySQL中几个基本的索引：普通索引、唯一索引、主键索引、全文索引。
优缺点：
- 加快数据检索速度
- 降低增删改等维护任务的速度
- 唯一索引可以确保每一行数据的唯一性
- 可以在查询过程中使用优化隐藏器，提高系统性能
- 占物理和数据空间（缺点）

然而，在使用索引查询数据时，需要注意到它的代价。**索引需要存储空间，也需要定期维护**，当表中记录被增减，或者索引列被修改时，索引本身也会被修改，将会因此多付出4，5次磁盘I/O。有时候，**不必要的索引反而会时查询反应时间变慢**，所使用索引并不一定提高查询性能。

索引查询适合两种情况：
- **基于一定范围的检索**，一般查询返回结果集小于表中记录数的30%；
- **基于非唯一性索引的检索**。

我的问题：如何创建索引？

# 事务

事务（Transaction）：并发控制的基本单位。它是一个操作序列，要么执行，要么都不执行，是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，保持数据一致性。

# 并发控制

乐观锁与悲观锁

**并发控制**确保多个事务在同时存取数据库中同一数据时，不破坏事务的隔离性和统一性，以及数据库的统一性。乐观锁和悲观锁为并发控制的主要技术手段。
- 悲观锁为悲观并发控制，它假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作；
- 乐观锁为乐观并发控制，它假定不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

# 删除操作

drop, delete, truncate 的区别？分别在什么场景下使用？

- 三者均为删除操作；
- delete 和 truncate 只删除表的数据不删除表的结构
- 速度：drop > truncate > delete
- delete 语句是 dml，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。truncate，drop 是 ddl，操作立即生效，原数据不放到 rollback segment 中，不能回滚。操作不触发 trigger。

场景：
- 不再需要一张表，用 drop；
- 删除部分数据行，用 delete，带上 where 子句；
- 保留表而删除所有数据，用 truncate。

# 键

超键、候选键、主键、外键是什么？

超键：在关系中**能唯一标识元组的属性集**称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含**候选键**和**主键**。
候选键：最小超键，即没有冗余元素的超键。
主键：数据库表中对储存数据对象予以**唯一和完整标识**的数据列或属性的组合。**一个数据列只能有一个主键**，且主键的取值不能缺失，即不能为空值（Null）。
外键：在一个表中存在的另一个表的主键称此表的外键。

# 视图

什么是视图？视图的使用场景？

视图是一种虚拟的表，具有和物理表相同的功能，可对视图进行增，改，查的操作。视图通常是一个表或者多个表的行或列的子集。相比多表查询，使得我们获取数据更容易。对视图的修改不影响基本表。

- 只暴露部分字段给访问者；
- 查询的数据来源于不同的表，而查询者希望以统一的方式查询，创建视图能把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异

# 范式

范式（Normal Form）：符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度。通俗地讲，就是一张数据表的表结构所符合的某种设计标准的级别。符合高一级范式的设计，必定符合低一级范式。范式作为设计的标准范式，其最大的意义就是为了避免数据的冗余和插入/删除/更新的异常。

第一范式 1NF：符合 1NF 关系中的每个属性都不可再分。也就是说，一个属性不能有子属性。1NF 是所有关系型数据库（RDB）的最基本要求。只要在关系型数据库管理系统中已经存在的数据表，一定是符合 1NF 的。如果仅仅符合 1NF 的设计，会存在数据冗余过大，插入异常，删除异常，修改异常等问题。故需要提高设计标准，解决导致上述问题的因素，使其符合更高一级范式，这就是所谓的“规范化”。

第二范式 2NF：2NF 在 1NF 的基础上，消除了非主属性对于码的部分函数依赖。2NF 要求，如果依赖于主键，则需要依赖于所有主键，不能存在依赖部分主键的情况。通俗说，就是不要把不相关的东西放到一个表中。不相关的东西不要放在一起，用多个小表连接来代替大表，减少修改时候的负担。
- 函数依赖：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那就可以说 Y 函数依赖于 X，写作 $X\toY$。函数依赖包括三种依赖：完全函数依赖、部分函数依赖、传递函数依赖。
- 码：假设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都**完全函数依赖**于 K，那么我们称 K 为候选码，简称为码。换句话说，假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。一张表中可以有超过一个码。实际应用中为了方便，通常选择其中的一个码作为主码。
- 非主属性：包含在任何一个码中的属性称为主属性。

判断是否符合 2NF 就是看数据表中是否存在非主属性对于码的部分函数依赖。若存在，则数据表最高只符合 1NF 的要求，若不存在，则符合 2NF 的要求。判断方法为：
- 第一步：找出数据表中所有的码。
- 第二步：根据第一步得到的码，找出所有的主属性。
- 第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。
- 第四步：查看是否存在非主属性对码的部分函数依赖。

如何消除部分函数依赖，从而让表符合 2NF 的要求？
- 将大数据表拆分成两个或者更多个更小的数据表，在拆分过程中，要达到更高一级范式的要求，这个过程叫做**模式分解**。模式分解方法不是唯一的。**如何进行模式分解呢？**

仅仅符合 2NF 的要求，仍然存在非主属性对于码的传递函数依赖。为了进一步解决问题，还需将数据表改进为符合 3NF 的要求。

第三范式 3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖。如果存在非主属性对于码的传递函数依赖，则不符合 3NF 的要求。3NF 避免了查询路径过长而导致询问时间过长或者更新异常，提高查询效率。然而，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在这插入、修改、删除异常。造成问题的原因在于，存在着主属性对于码的部分函数依赖和传递函数依赖。解决办法是在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。此时的设计为 BCNF 范式。BC 范式的每个表中只有一个候选键。

**所谓的范式，是用来学习参考的，设计的时候根据情况，未必一定要遵守。**

参考：
- [解释一下关系数据库的第一第二第三范式？刘慰、Lyken的回答](https://www.zhihu.com/question/24696366)

拓展阅读：
- [数据库范式那些事](http://www.cnblogs.com/CareySon/archive/2010/02/16/1668803.html)

---

参考资料：

- [知乎专栏-学习编程：常见面试题整理--数据库篇](https://zhuanlan.zhihu.com/p/23713529)
