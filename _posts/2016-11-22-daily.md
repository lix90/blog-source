---
title: 每日总结 2016-11-22
author: Li Xiang
date: 2016-11-22
layout: post
tags: [JavaScript,项目管理,单元测试,Conf,Chrome]
categories: [Daily]
---

# JavaScript：函数

## 函数声明与函数表达式

函数是对象，函数名是指针。
函数表达式最后有分号 `;`。
使用不带圆括号的函数名是访问函数指针，而非调用函数。
Firefox, Opera, Chrome, Safari 通过 `name` 属性，访问函数名 `function.name`。

**函数声明提升**：在执行代码前会先读取函数声明。也就是说，可以把函数声明放在调用它的语句之后。

每个函数继承的 `toLocaleString()` 和 `toString()` 方法始终都返回函数的代码。

``` javascript
var func = function() {console.log(5)}
func.toString()
'function () {console.log(5)}'
func.toLocaleString()
'function () {console.log(5)}'
```

**匿名函数**：`function` 关键字后面没有标识符。匿名函数的 `name` 属性为空字符串。

## apply & call

可在特定的作用域中调用函数，等同于设置函数体内 this 对象的值。
- `apply()` 方法接受两个参数：一个是在其中运行函数的作用域，另一个是**参数数组**。第二个参数可以为 Array 实例，也可以为 arguments 对象。
- `call()` 与 apply 方法的作用相同，区别在于**接受参数的方式不同**。使用 call 时，传递给函数的参数必须**逐个列举**出来。
> 传递函数并非 apply 和 call 真正的用武之地；他们真正强大的地方是能够**扩充函数赖以运行的作用域**。使用 call 和 apply 来扩充作用域的最大好处，就是**对象不需要与方法有任何耦合关系**。

ECMAScript 5 定义了一个新方法：`bind()`。该方法会创建一个函数的实例，其 this 值会被绑定到传给 bind 函数的值。

## 递归

**递归函数**：一个函数通过名字调用自身。`arguments.callee` 是一个指向正在执行的函数的指针，可以用它来实现对函数的递归调用。在编写递归函数时，使用 `arguments.callee` 总比使用函数名更保险。但在严格模式下，不能通过脚本访问 `arguments.callee`，访问这个属性会导致错误。此时可以通过命名函数表达式来实现对当前执行的函数的引用。

``` javascript
var factorial = (function f(num) { // 命名函数表达式
    if (num <= 1) {
        return 1;
    } else {
        return num * f(num-1);
    }
});
```

## 闭包

匿名函数 vs 闭包

**闭包**：有权访问**另一个函数作用域**中的**变量**的函数。在一个函数内部创建另一个函数，即可创建闭包。
理解闭包需要先理解作用域链。作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。

一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域。但是**闭包函数在执行完毕后仍然携带包含它的函数的作用域**，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多，所以**只在绝对必要时考虑使用闭包**。

作用域链的这种配置机制引出了一个值得注意的副作用，即**闭包只能取得包含函数中任何变量的最后一个值**。

### this 对象

`this` 对象是在运行时基于函数的执行环境绑定的：在全局函数中，`this` 等于 window，而当函数被作为某个对象的方法调用时，`this` 等于那个对象。匿名函数的执行环境具有全局性，因此其 `this` 对象通常指向 `window`。

每个函数在被调用时都会自动取得两个特殊变量：`this` 和 `arguments`。内部函数在搜索这两个变量时，只会搜索到其活动对象为止。因此永远不可能直接访问外部函数中的这两个变量。不过，把外部作用域中的 `this` 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了。如果想访问作用域中的 `arguments` 对象，必须将对该对象的引用保存到另一个闭包能够访问的变量中。

**即使是细微的变化，都有可能意外改变 `this` 的值。**

### 内存泄漏

闭包在 IE9 之前的版本中会导致一些特殊的问题。如果闭包的作用域链中保存着一个 HTML 元素，那么意味着该元素将无法被销毁。 >>> 内存泄漏

## 模仿块级作用域

JS 没有块级作用域的概念。JS 从不会告诉你是否多次声明了同一个变量，它只会读后续的声明视而不见（但是它会执行后续声明中的变量初始化）。**匿名函数**可以用来模仿块级作用域并避免这个问题。

``` javascript
(function(){
    // 这里是块级作用域
})();
// 这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。
```

``` javascript
var someFunction = function() {
    // 这里是块级作用域
};
```

一般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个由很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突。

## 私有变量

严格来讲，JS 中没有私有成员的概念；所有对象属性都是公有的。

私有变量
- 函数中定义的变量，可以认为是私有变量，因为在函数外部无法访问这些变量。
- 私有变量包括
  - 函数的参数
  - 局部变量
  - 在函数内部定义的其他函数

可以通过闭包来创建用于访问私有变量的公有方法。

**特权方法（previleged method）**：有权访问私有变量和私有函数的公有方法。

1) 在构造函数中定义特权方法。

``` javascript
function MyObject() {
    // 私有变量和私有函数
    var privateVariable = 10;
    function privateFunction(){
        return false;
    }
    //特权方法
    this.publicMethod = function (){
        privateVariable++;
        return privateFunction();
    };
}
```

2) 在私有作用域中定义私有变量或函数创建特权方法。

``` javascript
(function(){

    // 私有变量和私有函数
    var privateVariable = 10;

    function privateFunction(){
        return false;
    }

    // 构造函数
    MyObject = function(){
    };

    // 公有/特权方法
    MyObject.prototype.publicMethod = function(){
        privateVariable++;
        return privateFunction();
    };

})();
```

注意：在初始化未经声明的变量，总是会创建一个全局变量。但是，在严格模式下给未经声明的变量赋值会导致错误。

这个模式与在构造函数中定义特权方法的主要区别，在于**私有变量和函数是由实例共享的。**由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。

以这种方式创建静态私有变量会因为使用原型而增进代码复用，但**每个实例都没有自己的私有变量**。

3) 模块模式

单例指只有一个实例的对象。模块模式是为单例创建私有变量和特权方法。模块模式通过为单例添加私有变量和特权方法能够使其得到增强。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的。如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。

4) 增强的模块模式

**增强的模块模式**：在返回对象之前加入对其增强的代码，这种模式适合那些单例必须是某些类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况。

来源：《JavaScript 高级程序设计 第三版》

---

# JavaScript: 编写可维护的 JS 代码

如何把一个意大利面式的代码仓库整理成一个整洁、有组织并易扩展的项目代码？

1) 分析项目：把自己当成用户去审视项目
- 使用网站所有功能，打开开发者工具，看是否有报错或输出日志。
- Node.js 项目：打开名两行接口检查 api。最好的情况是项目有一个入口，通过入口能将所有模块初始化；最坏的情况也得找到每个业务逻辑的位置。
- 找出使用的工具，阅读工具的文档，寻找最佳实践。

2) 深入了解项目
- 单元测试：测试代码的功能和方法是否按预期调用的一种方法。通过单元测试深入了解代码。

3) 创建一个规范
- 建议添加一个 .editorconfig 文件来保证代码在不同的编辑器、IDE 或不同开发者之间的编写风格一致。

4) 代码缩进
5) 命名规则
6) 尽可能使用 lint：ESlint, JSlint, JSHint。
7) 更新依赖：更新依赖需谨慎，升级依赖没有通用的处理规则。
   - `npm outdated` 可以检查哪些依赖版本比较旧

**常见单元测试框架**：karma，jasmine，macha，ava。
如果测试用户界面，可以使用 Nightwatch.js 和 Dalekjs 这类**浏览器自动测试工具**。

**单元测试与浏览器自动化测试的区别**：前者测试 JS 本身代码，保证所有的模块和通用逻辑能预期运行；后者测试项目的用户界面，保证页面上的元素在预期正确的位置。

**在重构之前先建立好单元测试。**

**架构**
- 知道项目中使用到了何种设计模式。了解该模式，并保证它在整个项目中是一致的。在项目中可以使用不同的设计模式达到不同的目的，但是**绝对不要在一个模块中使用几种不同的设计模式**。
- 如果项目中没有用到什么架构，尽早作出改变。最基本的架构层级结构分为：
  - 第三方内容
  - 模块内容
  - 数据
  - 初始化所有模块
  - 逻辑入口

**模块化**
- 把功能划分成小的模块。
- 每个模块对应一个明确的目标功能。
- 应该无法通过一个模块知道外面代码逻辑。
- 模块能在不同的场景下复用。

**写注释**
- 可用 [JSDoc](http://usejsdoc.org/) 来管理文档。

**构建有组织的提交工作流程**
- 在新分支上重构，不要在主干上直接修改

来源：
- [伯乐在线：编写可维护的 JS 代码](http://web.jobbole.com/88909/)

## 个人总结

- 了解和分析项目
- 建立代码规范
- 注释和管理文档
- 管理依赖
- 重构前进行单元测试
- 了解设计模式
- 模块化
- 良好的版本控制流程习惯

# 阅读

## Chrome Dev Summit 2016

Progressive Web Apps (PWA)，能够提供类似 Native app 一样体验的 Web app。主要有几个特点：
- 可添加至桌面（可安装）
- 离线能力
- 消息推送
- 安全
- 响应式

Darin Fisher（选择我感兴趣的点）
- 移动端的挑战：分辨率，cpu，内存，电池，网络
- 印度 2.3 亿，美国 4.6 亿，中国 7.6 亿的网民
- **超过 3 秒的网页，53% 的用户选择离开**
- 在 3G 环境下，要确保页面 5 秒内加载完成
- “添加到主屏幕”这个功能提高了用户 4 倍的浏览频率
- Lighthouse 是个测试 PWA 的工具
- [browser-issue-tracker-search](https://browser-issue-tracker-search.appspot.com/) 为开发者提供的网站，包括bug，w3c 标准，API 建议等

Alex
- 手机网页打开的平均时间在 19s
- Motion Mark 测试，PC 要比手机端快 25 倍
- **使用真机 Debug**
- **重视低端设备**
- 硬件限制以至于手机不能比 PC 块
- [High Performance Browser Networking](https://hpbn.co/)
- 少加载 code，在合适的时间执行合适的代码
- Service Worker 不仅仅是离线，更重要的是提升效率

Paul - 关于 Web 未来发展方向
- **Web 一定会赶超 Native APIs**
- 手机游戏会与 Native 平起平坐，并带来更高的利润
- 现有 API：定位（Geolocation），相机（Camera），麦克风（Microphone），电池（Battery），权限（Permissions），网络状况（Network），自动填充（Autofill），用户授权（Credential Management API），支付（PaymentRequest API），消息推送（Push notifications），离线（Offline），可安装（Installability）
- SLICE（Secure，Linkable，Indexable，Composable，Ephemeral）
- [Doing Science On The Web](https://infrequently.org/2015/08/doing-science-on-the-web/)
- **新的交互方式**：Physical Web. Web Bluetooth. WebUSB. WebVR.

来源：[奇舞团博客](http://www.75team.com/post/cds.html)
