---
title: 每日总结 2016-11-28
author: Li Xiang
date: 2016-11-28
layout: post
tags: [JavaScript,jQuery,Front-end]
categories: [Daily]
description: "JS 看了 Date 和 RegExp 类型的内容。翻看了jQuery的一本书，记录了书中阐述的jQuery的众多优点。最后阅读了一篇关于前端工程化的文章。"
---

# JavaScript

## Date ##

构建 Date 类型
`var now = new Data()` 为传入参数将自动返回当前的日期和时间，为距 UTC 1970-1-1午夜零时的时间戳（毫秒）。若需创建特定日期和时间创建日期对象，需传入时间戳。

两个方法：输出因浏览器而异。
`Data.parse()` 接收日期的字符串参数然后返回时间戳。参数格式因本地语言设置有关。
`Data.UTC()` 接收的参数分别为年、月（0开始）、日、时、分、秒、毫秒。返回时间戳。

ECMAScript 5 新引入的方法
`Data.now()` 调用该方式时的日期和时间的毫秒数。

继承方法
Date 类型继承了 `toLocaleString()` `toString()` `valueOf()` 的方法，但输出值与其他类型的方法不同。

日期格式化方法
`toDateString()`
`toTimeString()`
`toLocaleDateString()`
`toLocaleTimeString()`
`toUTCString()`

日期/时间组件方法：直接取得和设置日期值中特定部分的方法 `get/set*`。

## RegExp 类型 ##

字面量 `/pattern/flags`
构造函数 `new RegExp(pattern[, flags])`

``` javascript
/ab+c/i;
new RegExp('ab+c', 'i');
new RegExp(/ab+c/, 'i');
```

**pattern** 任何简单或复杂的正则表达式，包含字符类、限定符、分组、先前查找、反向引用。构造函数下，pattern 也可以为字符串模式。
**flags** 每个正则表达式都可以带一个或多个标志（flags），用来标明正则表达式的行为。
- g：全局，遍历所有匹配项。
- i：不区分大小写。
- m：多行模式。

元字符：模式中所有元字符都必须转义，包括 `( [ { \ ^ $ | ) ? * + . ] }`。

### RegExp 实例属性 ###

RegExp 实例属性可以取得有关模式的各种信息：
- **global** 布尔值，是否设置了 g 标志。
- **ignore**Case 布尔值，是否设置了 i 标志。
- **lastIndex** 整数，表示开始搜索下一个匹配项的字符位置，从0算起。
- **multiline** 布尔值，是否设置了 m 标志。
- **source** 正则表达式的字符串表示，按照**字面量形式**返回。

### RegExp 构造函数属性 ###

RegExp 构造函数包含的一些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。这些属性分别有一个长属性名和一个短属性名。短属性名大都不是有效的 ECMAScript 标识符，因此必须通过方括号语法来访问它们。除此之外还有用9个用于存储捕获组的构造函数属性。访问这些属性的语法是 `RegExp.$1/2/.../9`。

长属性名 | 短属性名 | 说明
:-------|:--------|:----
`input` | `$_` | 最近一次要匹配的字符串
`lastMatch` | `$&` | 最近一次的匹配项
`lastParen` | `$+` | 最近一次匹配的捕获组
`leftContext` | `$`` | input 字符串中 lastMatch 之前的文本
`multiline` | `$*` | 布尔值，表示是否所有表达式都使用多行模式
`rightContext` | `$'` | input 字符串中 lastMatch 之后的文本

### 模式的局限性 ###

不支持的正则表达式特性：
- 匹配字符串开始和结尾的 `\A` 和 `\Z` 锚。（支持 `^` 和 `$` 匹配）
- 向后查找（但完全支持向前查找）
- 并集和交集类
- 原子组
- Unicode 支持（单个字符除外，如 \uFFFF）
- 命名的捕获组
- `s`（单行） 和 `x`（无间隔） 匹配模式
- 条件匹配
- 正则表达式注释

# jQuery

jQuery 的优势：
- 轻量级：采用 UglifyJS 压缩，保持在 30KB 左右。
- 强大的选择器：允许开发者使用 CSS 几乎所有选择器，以及独创的高级而复杂的选择器。开发者还可以编写自己的选择器。
- 出色的 DOM 操作的封装。
- 可靠的事件处理机制。
- 完善的 Ajax。所有 ajax 的操作都封装到一个函数 `$.ajax()` 里，使得开发者处理 ajax 的时候能够专心处理业务逻辑。
- 不污染顶层变量。该特性使得 jQuery 可以与其他 JS 库共存。
- 出色的浏览器兼容性。
- 链式操作方法。jQuery 最有特色的莫过于它的链式操作方式，即对发生在同一个 jQuery 对象上的一组动作，可以直接连写而无需重复获取对象。
- 隐式迭代。jQuery 里的方法都被设计成自动操作对象集合，而不是单独的对象。
- 行为层与结构层的分离。开发者可以使用 jQuery 选择器选中元素，然后直接给元素添加事件。
- 丰富的插件支持。jQuery 的易扩展性，吸引了来自全球的开发者来编写 jQuery 的扩展插件。
- 完善的文档。包括长期更新的中文文档。
- 开源。

来源：《锋利的 jQeury 第二版》

# 阅读：前端工程

## 笔记

> 从本质上讲，所有Web应用都是一种运行在网页浏览器中的软件，这些软件的图形用户界面（Graphical User Interface，简称GUI）即为前端。

前端工程的三个阶段
**第一阶段：库/框架选型。**根据项目特征进行技术选型，合理的技术选型可以为项目节省许多工程量这点毋庸置疑。
**第二阶段：简单构建优化。**选型之后基本上就可以开始敲码了，不过光解决开发效率还不够，必须要兼顾运行性能。前端工程进行到第二阶段会选型一种构建工具，对代码进行压缩，校验，之后再以页面为单位进行简单的资源合并。
**第三阶段：JS/CSS模块化开发。**分而治之是软件工程中的重要思想，是复杂系统开发和维护的基石，这点放在前端开发中同样适用。在解决了基本开发效率运行效率问题之后，前端团队开始**思考维护效率**，模块化是目前前端最流行的分治手段。模块化开发的最大价值应该是分治。
- JS 模块化方案，AMD/CommonJS/UMD/ES6 Module等。
- CSS 模块化方案，less、sass、stylus等预处理器的import/mixin特性支持下实现。

第四阶段
前端是一种**技术问题较少、工程问题较多**的软件开发领域。

在开发一款完整的Web应用时，前端将面临许多工程问题，比如：
- 大体量：多功能、多页面、多状态、多系统；
- 大规模：多人甚至多团队合作开发；
- 高性能：CDN 部署、缓存控制、文件指纹、缓存复用、请求合并、按需加载、同步/异步加载、移动端首屏 CSS 内嵌、HTTP 2.0 服务端资源推送。

用最少最简单明了的规则制定出最容易遵守最容易理解的开发规范或工具，以提升开发效率和工程质量，这同样是小而美的典范！

进入第四阶段，我们只需做好两件事就能大幅提升前端开发效率，并且兼顾运行性能，那就是——组件化开发与资源管理。

第一件事：组件化开发

> 前端作为一种GUI软件，光有JS/CSS的模块化还不够，对于UI组件的分治也有着同样迫切的需求。

前端组件化开发理念：
> 1. 页面上的每个独立的可视/可交互区域视为一个组件；
> 2. 每个组件对应一个工程目录，组件所需的各种资源都在这个目录下就近维护；
> 3. 由于组件具有独立性，因此组件与组件之间可以自由组合；
> 4. 页面只不过是组件的容器，负责组合组件形成功能完整的界面；
> 5. 当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换。

> 基于这样的工程理念，我们很容易将系统以独立的组件为单元进行分工划分。由于系统功能被分治到独立的模块或组件中，粒度比较精细，组织形式松散，开发者之间不会产生开发时序的依赖，大幅提升并行的开发效率，理论上允许随时加入新成员认领组件开发或维护工作，也更容易支持多个团队共同维护一个大型站点的开发。

整个前端项目可以划分为这么几种开发概念：
- **JS 模块**：**独立**的算法和数据单元。例如：浏览器环境监测；网络请求；应用配置。
- **CSS 模块**：**独立**的功能性样式单元。例如：栅格系统；字体图标；动画样式。
- **UI 组件**：**独立**的可视/可交互功能单元。例如：页头、页尾、导航栏。
- **页面**：前端这种 GUI 软件的界面状态，是 **UI 组件的容器**。例如：首页，列表页，用户管理。
- **应用**：**整个项目或整个站点**被称之为应用，由多个页面组成。

第二件事：“智能”静态资源管理

> 模块化/组件化开发之后，我们最终要解决的，就是模块/组件加载的技术问题。

> 前端是一种远程部署，运行时增量下载的GUI软件。前端应用没有安装过程，其所需程序资源都部署在远程服务器，用户使用浏览器访问不同的页面来加载不同的资源，随着页面访问的增加，渐进式的将整个程序下载到本地运行，**“增量下载”是前端在工程上有别于客户端GUI软件的根本原因。**

> 静态资源管理系统 = 资源表 + 资源加载框架
> 通过一个小工具扫描所有静态资源，生成一张资源表，然后有一个PHP实现的资源管理框架（Celerity）提供了资源加载接口，替代了传统的script/link等静态的资源加载标签，最终通过查表来加载资源。

> 资源表是非常通用的数据结构，无论什么业务场景，其业务代码最终都可以被扫描为相同结构的表数据，并标记资源间的依赖关系，有了表之后我们只需根据不同的业务场景定制不同的资源加载框架就行了，从此彻底告别一个团队维护一套工具的时代！！！


### 结论

作为初学者，无须把目标设为掌握前端工程话，但必须得提前**了解前端工程化**。从 fouber 这篇文章，有一些关键概念和理念。

**关键概念**
- 模块化与组件化
- 分治
- 三个效率：开发效率、运行效率（性能）、维护效率
- 增量下载

**关键观点**
- 前端即用户图形界面。
- 前端是一种**技术问题较少、工程问题较多**的软件开发领域。
- 静态资源管理系统 = 资源表 + 资源加载框架

FACEBOOK 3D:
> Allow product engineers to move fast: 3D
> - Simple **D**evelopment process
> - Quick **D**eployment
> - Easy **D**ebugging

内容来源：[fouber：前端工程——基础篇](https://github.com/fouber/blog/issues/10)
拓展阅读：[静态网页资源的管理和优化](http://velocity.oreilly.com.cn/2010/index.php?func=session&name=%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96)


# 概念

**没有银弹**：没有任何一项技术或方法能让软件工程的生产力在十年内提高十倍。[百度百科]
**粒度**：指数据仓库的数据单位中保存数据的细化或综合程度的级别。细化程度越高，粒度级就越小；相反，细化程度越低，粒度级就越大。数据的粒度一直是一个设计问题。在数据仓库环境中粒度之所以是主要的设计问题，是因为它**深深地影响存放在数据仓库中的数据量的大小，同时影响数据仓库所能回答的查询类型**。在数据仓库中的数据量大小与查询的详细程度之间要作出权衡。[百度百科]
